<!DOCTYPE html>
<html lang="en" data-theme="retro">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>8 Puzzler</title>
        <link rel="stylesheet" href="src/style.css" />
        <link rel="stylesheet" href="src/input.css" />
    </head>

    <body class="bg-base-100 min-h-screen">
        <div class="navbar bg-neutral text-neutral-content">
            <a class="btn btn-ghost normal-case text-xl">Eight Puzzler</a>
        </div>
        <div class="flex flex-col items-center justify-center align-middle">
            <div
                class="rounded-3xl bg-primary text-primary-content text-4xl w-fit p-8 m-4"
            >
                Welcome to A* Algorithm 8 Puzzler Demonstration
            </div>
        </div>

        <div class="flex w-full h-2/3 mt-8">
            <div
                class="flex-1 h-fit p-4 m-4 ml-8 flex flex-col card bg-base-300 rounded-box pb-16"
            >
                <div class="text-3xl p-4 m-4">
                    You can shuffle the Puzzle manually, and then click the
                    Solve button to see the solution.
                </div>
                <div class="text-3xl p-4 m-4">
                    Enter the Size of the Puzzle Grid
                </div>
                <div class="p-4 m-4 mt-0 pt-0">
                    <input
                        min="3"
                        max="10"
                        id="size-input"
                        value="3"
                        type="number"
                        placeholder="Type here"
                        class="input input-bordered input-accent w-full max-w-xs text-3xl"
                    />
                </div>

                <div
                    class="p-4 m-4 mt-0 pt-0 flex gap-8 items-center justify-start"
                >
                    <button
                        id="shuffle"
                        class="btn btn-accent btn-lg"
                        onclick="shufflePuzzle()"
                    >
                        Shuffle
                    </button>

                    <button
                        id="solve-button"
                        class="btn btn-accent btn-lg"
                        onclick="solvePuzzle()"
                    >
                        Solve
                    </button>
                </div>

                <div
                    id="comment"
                    class="text-3xl text-base-content p-4 m-4 mt-0 pt-0"
                >
                    Click Shuffle to start!
                </div>
            </div>
            <div class="divider divider-horizontal"></div>
            <div
                class="flex-1 flex p-4 m-4 mr-8 flex-col h-full card bg-base-300 rounded-box"
                id="puzzle-container"
            ></div>
        </div>

        <script>
            // Define the goal state of the puzzle
            const goalState = [1, 2, 3, 4, 5, 6, 7, 8, 0];

            // Define the possible moves for each tile
            const moves = {
                0: [1, 3],
                1: [0, 2, 4],
                2: [1, 5],
                3: [0, 4, 6],
                4: [1, 3, 5, 7],
                5: [2, 4, 8],
                6: [3, 7],
                7: [4, 6, 8],
                8: [5, 7],
            };

            // Define the heuristic function (Manhattan distance)
            function heuristic(state) {
                let distance = 0;
                for (let i = 0; i < state.length; i++) {
                    if (state[i] !== 0) {
                        distance +=
                            Math.abs(
                                (i % 3) - (goalState.indexOf(state[i]) % 3)
                            ) +
                            Math.abs(
                                Math.floor(i / 3) -
                                    Math.floor(goalState.indexOf(state[i]) / 3)
                            );
                    }
                }
                return distance;
            }

            // Define the A* algorithm
            function aStar(startState) {
                let openSet = [startState];
                let closedSet = [];
                let gScore = { [startState.join("")]: 0 };
                let fScore = { [startState.join("")]: heuristic(startState) };
                while (openSet.length > 0) {
                    let current = openSet[0];
                    let currentIndex = 0;
                    for (let i = 1; i < openSet.length; i++) {
                        if (
                            fScore[openSet[i].join("")] <
                            fScore[current.join("")]
                        ) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    if (current.join("") === goalState.join("")) {
                        return current;
                    }
                    openSet.splice(currentIndex, 1);
                    closedSet.push(current);
                    for (let i = 0; i < moves[current.indexOf(0)].length; i++) {
                        let neighbor = current.slice();
                        let index = neighbor.indexOf(0);
                        let swapIndex = moves[index][i];
                        [neighbor[index], neighbor[swapIndex]] = [
                            neighbor[swapIndex],
                            neighbor[index],
                        ];
                        if (
                            closedSet.some(
                                (state) => state.join("") === neighbor.join("")
                            )
                        ) {
                            continue;
                        }
                        let tentativeGScore = gScore[current.join("")] + 1;
                        if (
                            !openSet.some(
                                (state) => state.join("") === neighbor.join("")
                            )
                        ) {
                            openSet.push(neighbor);
                        } else if (
                            tentativeGScore >= gScore[neighbor.join("")]
                        ) {
                            continue;
                        }
                        gScore[neighbor.join("")] = tentativeGScore;
                        fScore[neighbor.join("")] =
                            gScore[neighbor.join("")] + heuristic(neighbor);
                    }
                }
                return null;
            }

            // Define the function to generate a random solvable puzzle
            function generatePuzzle(size) {
                let puzzle = [];
                for (let i = 0; i < size * size; i++) {
                    puzzle.push(i);
                }
                do {
                    for (let i = puzzle.length - 1; i > 0; i--) {
                        let j = Math.floor(Math.random() * (i + 1));
                        [puzzle[i], puzzle[j]] = [puzzle[j], puzzle[i]];
                    }
                } while (!isSolvable(puzzle));
                return puzzle;
            }

            // Define the function to check if a puzzle is solvable
            function isSolvable(puzzle) {
                let inversions = 0;
                for (let i = 0; i < puzzle.length; i++) {
                    for (let j = i + 1; j < puzzle.length; j++) {
                        if (
                            puzzle[i] > puzzle[j] &&
                            puzzle[i] !== 0 &&
                            puzzle[j] !== 0
                        ) {
                            inversions++;
                        }
                    }
                }
                return inversions % 2 === 0;
            }

            // Define the function to render the puzzle
            function renderPuzzle(puzzle, size) {
                let puzzleContainer =
                    document.getElementById("puzzle-container");
                puzzleContainer.innerHTML = "";
                for (let i = 0; i < size * size; i++) {
                    let tile = document.createElement("div");
                    tile.classList.add("tile");
                    tile.style.width = `${100 / size}%`;
                    tile.style.height = `${100 / size}%`;
                    if (puzzle[i] === 0) {
                        tile.classList.add("empty");
                    } else {
                        tile.style.backgroundPosition = `-${
                            (puzzle[i] % size) * (100 / (size - 1))
                        }% -${
                            Math.floor(puzzle[i] / size) * (100 / (size - 1))
                        }%`;
                    }
                    puzzleContainer.appendChild(tile);
                }
            }

            // Define the function to handle the shuffle button click
            function shufflePuzzle() {
                let size = parseInt(
                    document.getElementById("size-input").value
                );
                let puzzle = generatePuzzle(size);
                renderPuzzle(puzzle, size);
                document.getElementById("comment").innerHTML =
                    "Click Solve to see the solution!";
            }

            // Define the function to handle the solve button click
            function solvePuzzle() {
                let size = parseInt(
                    document.getElementById("size-input").value
                );
                let puzzle = [];
                let tiles = document.querySelectorAll(".tile");
                for (let i = 0; i < tiles.length; i++) {
                    let x = Math.floor(
                        (i % (size * size)) / size
                    );
                    let y = i % size;
                    if (tiles[i].classList.contains("empty")) {
                        puzzle.push(0);
                    } else {
                        puzzle.push(
                            y + x * size + 1 > size * size - 1
                                ? 0
                                : y + x * size + 1
                        );
                    }
                }
                let solution = aStar(puzzle);
                if (solution === null) {
                    alert("No solution found!");
                } else {
                    let steps = [];
                    while (solution.join("") !== puzzle.join("")) {
                        let index = solution.indexOf(0);
                        let swapIndex = solution.indexOf(puzzle[index]);
                        [solution[index], solution[swapIndex]] = [
                            solution[swapIndex],
                            solution[index],
                        ];
                        steps.push(solution.slice());
                    }
                    steps.reverse();
                    let i = 0;
                    let interval = setInterval(() => {
                        renderPuzzle(steps[i], size);
                        i++;
                        if (i === steps.length) {
                            clearInterval(interval);
                        }
                    }, 500);
                }
            }

            // Add event listeners to the shuffle and solve buttons
            document
                .getElementById("shuffle")
                .addEventListener("click", shufflePuzzle);
            document
                .getElementById("solve-button")
                .addEventListener("click", solvePuzzle);
        </script>
    </body>
</html>